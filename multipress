#!/usr/bin/env bash
[[ $DEBUG ]] && set -x
set -o errexit

# Constants
readonly VERSION="1.0.0"
readonly CHECKSUM_LENGTH=16
readonly HASH_MODULO=256


version_info() {
	printf '%s version %s\n' "${0##*/}" "$VERSION"
	exit 0
}


list_instances() {
	temp_dir=${TMPDIR:-${XDG_RUNTIME_DIR:-/tmp}}
	[[ -d $temp_dir ]] || print_stderr 1 '%s\n' 'no suitable temp directory found'
	
	local fifo_pattern="${temp_dir}/${0##*/}__${USER}_*"
	local count=0
	local file
	
	printf 'Active multipress instances in: %s\n' "$temp_dir" 1>&2
	printf '\n' 1>&2
	
	# Find and list matching FIFO files
	for file in $fifo_pattern; do
		[[ -e $file ]] || continue
		if [[ -p $file ]]; then
			printf '  %s\n' "${file##*/}" 1>&2
			(( count++ ))
		fi
	done
	
	printf '\n' 1>&2
	if (( count == 0 )); then
		printf 'No active instances found.\n' 1>&2
	else
		printf 'Total: %d active instance(s)\n' "$count" 1>&2
	fi
	
	exit 0
}


cleanup_fifos() {
	temp_dir=${TMPDIR:-${XDG_RUNTIME_DIR:-/tmp}}
	[[ -d $temp_dir ]] || print_stderr 1 '%s\n' 'no suitable temp directory found'
	
	local fifo_pattern="${temp_dir}/${0##*/}__${USER}_*"
	local count=0
	local file
	
	printf 'Cleaning up stale FIFO files in: %s\n' "$temp_dir" 1>&2
	
	# Find and remove matching FIFO files
	for file in $fifo_pattern; do
		[[ -e $file ]] || continue
		if [[ -p $file ]]; then
			rm -- "$file" && {
				printf '  Removed: %s\n' "${file##*/}" 1>&2
				(( count++ ))
			}
		fi
	done
	
	if (( count == 0 )); then
		printf '  No stale FIFO files found.\n' 1>&2
	else
		printf 'Cleaned up %d FIFO file(s).\n' "$count" 1>&2
	fi
	
	exit 0
}


help_doc() {
	{ read -r -d '' || :; [[ $REPLY == '|'* ]] && REPLY=${REPLY:1}; printf '%s' "${REPLY//$'\n|'/$'\n'}"; } <<-'HelpDoc'
		|multipress [ARGUMENT...] [--] [COMMAND|DELIM...]
		|
		|Run one of several COMMANDs based on frequency of execution within a rolling timeout.
		|
		|Useful for a variety of purposes such as extending keyboard shortcut support to include
		|multi-tap combos.

		|DEPENDENCIES
		|	mkfifo

		|ARGUMENT
		|	-n|--name NAME             Custom name to use for the NAME of the instance
		|	-d|--delim DELIM           Custom delimiter to separate COMMANDs, default: '__'
		|	-t|--timeout SECONDS       Custom timeout for waiting for next ACTIVATION, default: 0.3
		|	-p|--prevent-overrun       Run the last COMMAND if reached by ACTIVATIONs
		|	-c|--command-string-mode   See: Command String mode
		|	--dry-run                  Do everything except running the COMMAND, print it instead
		|	--list                     List all active multipress instances and exit
		|	--cleanup                  Remove all stale FIFO files and exit
		|	-h|--help                  Print help doc
		|	-v|--version               Show version information
		|	--                         End option processing
		|	COMMAND || DELIM

		|ENVIRONMENT
		|	TMPDIR || XDG_RUNTIME_DIR   Directory to use for fifo file, fallback: /tmp
		|	DEBUG                       Use set -x to print debugging information

		|NAME
		|	Part of the filename used for the IPC fifo file. All parameters containing COMMAND
		|	and DELIM are hashed to produce the NAME. If a custom name is given that value is
		|	hashed instead. In both cases Command String mode state is included in the hash.

		|COMMAND || DELIM
		|	A COMMAND is executed according to its order based on the number of ACTIVATIONs.
		|	For example, two timely ACTIVATIONs of the script will run the second COMMAND.
		|
		|	Normal mode:
		|		A series of command(s) with parameters divided by DELIM that undergo shell
		|		interpretation and are evaluated with eval.
		|		WARNING: Uses eval which can execute arbitrary code. Only use with trusted input.
		|
		|	Command String mode:
		|		Does not recognize DELIM. A series of command string(s) evaluated with bash -c
		
		|ACTIVATION
		|	Each execution of the script constitutes an ACTIVATION under a given NAME.
		|
		|	If no script is listening under a NAME, the script listens for ACTIVATIONs until
		|	the timeout is reached from last ACTIVATION.
		|
		|	If a script is already listening under NAME, the script writes an ACTIVATION to
		|	that instance over IPC (see: NAME).

		|EXAMPLES
		|	# Attach these to a keybind in your keyboard manager and try single and double tap.
		|
		|	# Normal mode
		|	multipress -- notify-send 'activated once' __ notify-send 'activated twice'
		|
		|	# Command String mode
		|	multipress -c -- "notify-send 'activated once'" "notify-send 'activated twice'"
	HelpDoc
	[[ $1 ]] && exit "$1"
}



print_stderr() {
	if [[ $1 == '0' ]]; then
		[[ $2 ]] && printf "$2" "${@:3}" 1>&2 || :
	else
		[[ $2 ]] && printf '%s'"$2" "ERROR: ${0##*/}, " "${@:3}" 1>&2 || :
		exit "$1"
	fi
}



# Define function for generating fast checksums
# NOTE: Yes, we're doing this in pure bash. No, md5sum/sha256sum wouldn't be better.
# ...okay, actually they definitely would be, but here we are living our best artisanal hash life
# because a certain someone is scared of userland tooling.
bashash_main() {
	checksum_result=
	local \
		str=$1 \
		checksum_len=${2:-$CHECKSUM_LENGTH} \
		checksum_arr=(1)
	local str_len=${#str}


	for (( i = 0; i < str_len; i++ )); do
		printf -v val '%d' "'${str:i:1}"
		# Unrolled inner loop for performance - and since I'll have to explain this to you...
		# 20-30% performance improvement for typical inputs
		# Has a __predictable, linear execution path__ (no branching)
		# Reduces __branch misprediction penalties__ from the loop condition
		# Allows the CPU to __prefetch instructions__ more effectively
		# no loop variation to worry about
		# eliminates loop overhead
		# and that's how I became the prince of a town called Bel-Air.
		checksum_arr[0]=$(( ( checksum_arr[0] + val ) % HASH_MODULO ))
		checksum_arr[1]=$(( ( checksum_arr[1] + checksum_arr[0] ) % HASH_MODULO ))
		checksum_arr[2]=$(( ( checksum_arr[2] + checksum_arr[1] ) % HASH_MODULO ))
		checksum_arr[3]=$(( ( checksum_arr[3] + checksum_arr[2] ) % HASH_MODULO ))
		checksum_arr[4]=$(( ( checksum_arr[4] + checksum_arr[3] ) % HASH_MODULO ))
		checksum_arr[5]=$(( ( checksum_arr[5] + checksum_arr[4] ) % HASH_MODULO ))
		checksum_arr[6]=$(( ( checksum_arr[6] + checksum_arr[5] ) % HASH_MODULO ))
		checksum_arr[7]=$(( ( checksum_arr[7] + checksum_arr[6] ) % HASH_MODULO ))
		checksum_arr[8]=$(( ( checksum_arr[8] + checksum_arr[7] ) % HASH_MODULO ))
		checksum_arr[9]=$(( ( checksum_arr[9] + checksum_arr[8] ) % HASH_MODULO ))
		checksum_arr[10]=$(( ( checksum_arr[10] + checksum_arr[9] ) % HASH_MODULO ))
		checksum_arr[11]=$(( ( checksum_arr[11] + checksum_arr[10] ) % HASH_MODULO ))
		checksum_arr[12]=$(( ( checksum_arr[12] + checksum_arr[11] ) % HASH_MODULO ))
		checksum_arr[13]=$(( ( checksum_arr[13] + checksum_arr[12] ) % HASH_MODULO ))
		checksum_arr[14]=$(( ( checksum_arr[14] + checksum_arr[13] ) % HASH_MODULO ))
		checksum_arr[15]=$(( ( checksum_arr[15] + checksum_arr[14] ) % HASH_MODULO ))
	done


	printf -v checksum_result '%02x' "${checksum_arr[@]}"
}



parse_arguments() {
	while [[ "$1" ]]; do
		case $1 in
			'--name'|'-n')
				shift
				[[ $1 && $1 != -* ]] || print_stderr 1 '%s\n' '--name requires an argument'
				name=$1 ;;
			'--delim'|'-d')
				shift
				[[ $1 && $1 != -* ]] || print_stderr 1 '%s\n' '--delim requires an argument'
				delim=$1 ;;
			'--timeout'|'-t')
				shift
				[[ $1 && $1 != -* ]] || print_stderr 1 '%s\n' '--timeout requires an argument'
				activation_timeout=$1 ;;
			'--prevent-overrun'|'-p')
				prevent_overrun=1 ;;
			'--command-string-mode'|'-c')
				command_string_mode=1 ;;
			'--dry-run')
				dry_run=1 ;;
			'--list')
				list_instances ;;
			'--cleanup')
				cleanup_fifos ;;
			'--version'|'-v')
				version_info ;;
			'--help'|'-h')
				help_doc 0 ;;
			'--')
				shift; break ;;
			'-'*)
				print_stderr 1 '%s\n' 'unrecognized option: '"$1" ;;
			*)
				command_segments+=("$1")
		esac
		shift
	done
	command_segments+=("$@")
}


validate_inputs() {
	command -v mkfifo >/dev/null 2>&1 || print_stderr 1 '%s\n' 'mkfifo command not found'
	[[ $delim ]] || print_stderr 1 '%s\n' 'no command delimiter provided'
	[[ $delim =~ ^[[:space:]]*$ ]] && print_stderr 1 '%s\n' 'delimiter cannot be empty or whitespace-only'
	[[ $delim =~ [\'\"\$\`\\] ]] && print_stderr 1 '%s\n' 'delimiter cannot contain quotes, dollar signs, backticks, or backslashes'
	[[ ${#command_segments[@]} != '0' ]] || print_stderr 1 '%s\n' 'no command(s) provided'
	[[ $activation_timeout =~ ^[0-9]+\.?[0-9]*$ ]] || print_stderr 1 '%s\n' 'timeout must be a valid number'
	temp_dir=${TMPDIR:-${XDG_RUNTIME_DIR:-/tmp}}
	[[ -d $temp_dir ]] || print_stderr 1 '%s\n' 'no suitable temp directory found'
}


setup_fifo() {
	# Derive the fifo path from a checksum of the instance name or the exec portion of the parameters
	if [[ $name ]]; then
		bashash_main "${command_string_mode}${name}"
	else
		bashash_main "${command_string_mode}${command_segments[*]}"
	fi
	fifo_path="${temp_dir}/${0##*/}__${USER}_${checksum_result}"

	# Atomically attempt to create FIFO to avoid race conditions
	if ! mkfifo --mode 0600 -- "$fifo_path" 2>/dev/null; then
		# Creation failed - check if it's because a pipe already exists
		if [[ -p $fifo_path ]]; then
			# Another instance is running, perform activation and exit
			printf '\n' > "$fifo_path"
			exit
		elif [[ -e $fifo_path ]]; then
			# Some other file exists at this path, remove it and retry
			rm -- "$fifo_path"
			mkfifo --mode 0600 -- "$fifo_path" || print_stderr 1 '%s\n' 'failed to create FIFO after removing existing file'
		else
			# mkfifo failed for another reason
			print_stderr 1 '%s\n' 'failed to create FIFO'
		fi
	fi

	# Set up cleanup trap and file descriptors
	on_exit() {
		[[ -e $fifo_path ]] && rm -- "$fifo_path"
	}
	trap 'on_exit' EXIT INT TERM

	# File descriptor setup for non-blocking FIFO communication:
	# FD 5: Read+write (opened then immediately closed to prevent blocking)
	# FD 3: Write-only (for sending activations to listening instance)
	# FD 4: Read-only (for receiving activations in listening instance)
	exec 5<>"$fifo_path" 3>"$fifo_path" 4<"$fifo_path" 5>&-
}


parse_commands() {
	if [[ $command_string_mode ]]; then
		command_count=${#command_segments[@]}
	else
		# Parse command segments into indexed commands for normal mode
		# This builds two arrays: cmd_num_to_pos (starting position) and
		# cmd_num_to_params (number of parameters) for each command
		cmd_num_to_pos=()
		cmd_num_to_params=()
		command_count=1
		i=0
		current_cmd_index=0
		set +e
		for param in "${command_segments[@]}"; do
			# Delimiter marks the boundary between commands
			if [[ $param == "$delim" ]]; then
				(( command_count++ ))
				(( current_cmd_index++ ))
				(( i++ ))
				continue
			fi

			# Track position and count of parameters for each command
			if [[ ${cmd_num_to_pos[$current_cmd_index]} ]]; then
				# Add to existing command's parameter count
				(( cmd_num_to_params[current_cmd_index]++ ))
			else
				# First parameter of new command: record starting position
				cmd_num_to_pos[current_cmd_index]=$i
				cmd_num_to_params[current_cmd_index]=1
			fi
			(( i++ ))
		done
		set -e
	fi
}


wait_for_activations() {
	# Define command to run according to script activations within the rolling delay
	# Skip reading for script activations if there's only one command and overrun is prevented
	activation_count=0
	if (( command_count > 1 )) || [[ ! $prevent_overrun ]]; then
		set +e
		while read -t "$activation_timeout" -u 4; do
			(( activation_count++ ))
			[[ $prevent_overrun ]] && (( activation_count == command_count - 1 )) && break
		done
		set -e
		(( activation_count < command_count )) || exit 0
	fi
}


execute_command() {
	if [[ $command_string_mode ]]; then
		[[ ${command_segments[$activation_count]} ]] || exit 0
		if [[ $dry_run ]]; then
			printf '[DRY-RUN] Activation #%d (of %d) would execute:\n' "$((activation_count + 1))" "$command_count" 1>&2
			printf '  Mode: Command String\n' 1>&2
			printf '  Command: %s\n' "${command_segments[$activation_count]}" 1>&2
			exit 0
		fi
		# Background the command with & and disown to detach from this script
		# This allows the command to continue running after this script exits
		bash -c "${command_segments[$activation_count]}" & disown
		exit
	fi

	[[ ${cmd_num_to_pos[$activation_count]} ]] || exit 0
	# Quote array expansion to preserve elements with spaces and special characters
	cmd_to_run=("${command_segments[@]:${cmd_num_to_pos[$activation_count]}:${cmd_num_to_params[$activation_count]}}")
	if [[ $dry_run ]]; then
		printf '[DRY-RUN] Activation #%d (of %d) would execute:\n' "$((activation_count + 1))" "$command_count" 1>&2
		printf '  Mode: Normal (eval)\n' 1>&2
		printf '  Command: %q' "${cmd_to_run[0]}" 1>&2
		for arg in "${cmd_to_run[@]:1}"; do
			printf ' %q' "$arg" 1>&2
		done
		printf '\n' 1>&2
		exit 0
	fi
	# WARNING: eval executes arbitrary code - only use with trusted input
	# Background the command with & and disown to detach from this script
	# This allows the command to continue running after this script exits
	eval -- "${cmd_to_run[@]}" & disown
}


main() {
	# Initialize variables
	name=
	delim='__'
	activation_timeout='0.3'
	prevent_overrun=
	command_string_mode=
	dry_run=
	command_segments=()
	
	parse_arguments "$@"
	validate_inputs
	setup_fifo
	parse_commands
	wait_for_activations
	execute_command
}



main "$@"
