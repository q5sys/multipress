#!/usr/bin/env bash
[[ $DEBUG ]] && set -x
set -o errexit


help_doc() {
	{ read -r -d '' || :; [[ $REPLY == '|'* ]] && REPLY=${REPLY:1}; printf '%s' "${REPLY//$'\n|'/$'\n'}"; } <<-'HelpDoc'
		|multipress [ARGUEMENT...] [--] [COMMAND|DELIM...]
		|
		|Run one of several COMMANDs based on frequency of execution within a rolling timeout.
		|
		|Useful for a variety of purposes such as extending keyboard shortcut support to include
		|multi-tap combos.

		|DEPENDENCIES
		|	mkfifo

		|ARGUEMENT
		|	-n|--name NAME             Custom name to use for the NAME of the instance
		|	-d|--delim DELIM           Custom delimiter to seperate COMMANDs, default: '__'
		|	-t|--timeout SECONDS       Custom timeout for waiting for next ACTIVATION, default: 0.3
		|	-p|--prevent-overrun       Run the last COMMAND if reached by ACTIVATIONs
		|	-c|--command-string-mode   See: Command String mode
		|	--dry-run                  Do everything except running the COMMAND, print it instead
		|	-h|--help                  Print help doc
		|	--                         End option processing
		|	COMMAND || DELIM

		|ENVIRONMENT
		|	TMPDIR || XDG_RUNTIME_DIR   Directory to use for fifo file, fallback: /tmp
		|	DEBUG                       Use set -x to print debugging information

		|NAME
		|	Part of the filename used for the IPC fifo file. All parameters containing COMMAND
		|	and DELIM are hashed to produce the NAME. If a custom name is given that value is
		|	hashed instead. In both cases Command String mode state is included in the hash.

		|COMMAND || DELIM
		|	A COMMAND is executed according to its order based on the number of ACTIVATIONs.
		|	For example, two timely ACTIVATIONs of the script will run the second COMMAND.
		|
		|	Normal mode:
		|		A series of command(s) with parameters divided by DELIM that undergo shell
		|		interpretation and are evaluated with eval.
		|		WARNING: Uses eval which can execute arbitrary code. Only use with trusted input.
		|
		|	Command String mode:
		|		Does not recognize DELIM. A series of command string(s) evaluated with bash -c
		
		|ACTIVATION
		|	Each execution of the script constitutions an ACTIVATION under a given NAME.
		|
		|	If no script is listening under a NAME, the script listens for ACTIVATIONs until
		|	the timeout is reached from last ACTIVATION.
		|
		|	If a script is already listening under NAME, the script writes an ACTIVATION to
		|	that instance over IPC (see: NAME).

		|EXAMPLES
		|	# Attach these to a keybind in your keyboard manager and try single and double tap.
		|
		|	# Normal mode
		|	multipress -- notify-send 'activated once' __ notify-send 'activated twice'
		|
		|	# Command String mode
		|	multipress -c -- "notify-send 'activated once'" "notify-send 'activated twice'"
	HelpDoc
	[[ $1 ]] && exit "$1"
}



print_stderr() {
	if [[ $1 == '0' ]]; then
		[[ $2 ]] && printf "$2" "${@:3}" 1>&2 || :
	else
		[[ $2 ]] && printf '%s'"$2" "ERROR: ${0##*/}, " "${@:3}" 1>&2 || :
		exit "$1"
	fi
}



# Define function for generating fast checksums
bashash_main() {
	checksum_result=
	local \
		str=$1 \
		checksum_len=${2:-16} \
		checksum_arr=(1)
	local str_len=${#str}


	for (( i = 0; i < str_len; i++ )); do
		printf -v val '%d' "'${str:i:1}"
		checksum_arr[0]=$(( ( checksum_arr[0] + val ) % 256 ))
		for (( i2 = 1; i2 < checksum_len; i2++ )); do
			checksum_arr[i2]=$(( ( checksum_arr[i2] + checksum_arr[i2-1] ) % 256 ))
		done
	done


	printf -v checksum_result '%02x' "${checksum_arr[@]}"
}



parse_arguments() {
	while [[ "$1" ]]; do
		case $1 in
			'--name'|'-n')
				shift
				[[ $1 && $1 != -* ]] || print_stderr 1 '%s\n' '--name requires an argument'
				name=$1 ;;
			'--delim'|'-d')
				shift
				[[ $1 && $1 != -* ]] || print_stderr 1 '%s\n' '--delim requires an argument'
				delim=$1 ;;
			'--timeout'|'-t')
				shift
				[[ $1 && $1 != -* ]] || print_stderr 1 '%s\n' '--timeout requires an argument'
				activation_timeout=$1 ;;
			'--prevent-overrun'|'-p')
				prevent_overrun=1 ;;
			'--command-string-mode'|'-c')
				command_string_mode=1 ;;
			'--dry-run')
				dry_run=1 ;;
			'--help'|'-h')
				help_doc 0 ;;
			'--')
				shift; break ;;
			'-'*)
				print_stderr 1 '%s\n' 'unrecognized option: '"$1" ;;
			*)
				command_segments+=("$1")
		esac
		shift
	done
	command_segments+=("$@")
}


validate_inputs() {
	command -v mkfifo >/dev/null 2>&1 || print_stderr 1 '%s\n' 'mkfifo command not found'
	[[ $delim ]] || print_stderr 1 '%s\n' 'no command delimiter provided'
	[[ $delim =~ ^[[:space:]]*$ ]] && print_stderr 1 '%s\n' 'delimiter cannot be empty or whitespace-only'
	[[ $delim =~ [\'\"\$\`\\] ]] && print_stderr 1 '%s\n' 'delimiter cannot contain quotes, dollar signs, backticks, or backslashes'
	[[ ${#command_segments[@]} != '0' ]] || print_stderr 1 '%s\n' 'no command(s) provided'
	[[ $activation_timeout =~ ^[0-9]+\.?[0-9]*$ ]] || print_stderr 1 '%s\n' 'timeout must be a valid number'
	temp_dir=${TMPDIR:-${XDG_RUNTIME_DIR:-/tmp}}
	[[ -d $temp_dir ]] || print_stderr 1 '%s\n' 'no suitable temp directory found'
}


setup_fifo() {
	# Derive the fifo path from a checksum of the instance name or the exec portion of the parameters
	if [[ $name ]]; then
		bashash_main "${command_string_mode}${name}"
	else
		bashash_main "${command_string_mode}${command_segments[*]}"
	fi
	fifo_path="${temp_dir}/${0##*/}__${USER}_${checksum_result}"

	# Atomically attempt to create FIFO to avoid race conditions
	if ! mkfifo --mode 0600 -- "$fifo_path" 2>/dev/null; then
		# Creation failed - check if it's because a pipe already exists
		if [[ -p $fifo_path ]]; then
			# Another instance is running, perform activation and exit
			printf '\n' > "$fifo_path"
			exit
		elif [[ -e $fifo_path ]]; then
			# Some other file exists at this path, remove it and retry
			rm -- "$fifo_path"
			mkfifo --mode 0600 -- "$fifo_path" || print_stderr 1 '%s\n' 'failed to create FIFO after removing existing file'
		else
			# mkfifo failed for another reason
			print_stderr 1 '%s\n' 'failed to create FIFO'
		fi
	fi

	# Set up cleanup trap and file descriptors
	on_exit() {
		[[ -e $fifo_path ]] && rm -- "$fifo_path"
	}
	trap 'on_exit' EXIT INT TERM

	exec 5<>"$fifo_path" 3>"$fifo_path" 4<"$fifo_path" 5>&-
}


parse_commands() {
	if [[ $command_string_mode ]]; then
		max_command_index=$(( ${#command_segments[@]} - 1 ))
	else
		# Define index and number of parameters of each command
		cmd_num_to_pos=()
		cmd_num_to_params=()
		max_command_index=0
		i=0
		set +e
		for param in "${command_segments[@]}"; do
			if [[ $param == "$delim" ]]; then
				(( max_command_index++ ))
				(( i++ ))
				continue
			fi

			if [[ ${cmd_num_to_pos[$max_command_index]} ]]; then
				(( cmd_num_to_params[max_command_index]++ ))
			else
				# New command
				cmd_num_to_pos[max_command_index]=$i
				cmd_num_to_params[max_command_index]=1
			fi
			(( i++ ))
		done
		set -e
	fi
}


wait_for_activations() {
	# Define command to run according to script activations within the rolling delay
	# Skip reading for script activations if there's only one command and overun is prevented
	activation_count=0
	if (( max_command_index > 0 )) || [[ ! $prevent_overrun ]]; then
		set +e
		while read -t "$activation_timeout" -u 4; do
			(( activation_count++ ))
			[[ $prevent_overrun ]] && (( activation_count == max_command_index )) && break
		done
		set -e
		(( activation_count <= max_command_index )) || exit 0
	fi
}


execute_command() {
	if [[ $command_string_mode ]]; then
		[[ ${command_segments[$activation_count]} ]] || exit 0
		[[ $dry_run ]] && bash() { printf '%q ' 'bash' "$@"; printf '\n'; } 1>&2
		bash -c "${command_segments[$activation_count]}" & disown
		exit
	fi

	[[ ${cmd_num_to_pos[$activation_count]} ]] || exit 0
	# Quote array expansion to preserve elements with spaces and special characters
	cmd_to_run=("${command_segments[@]:${cmd_num_to_pos[$activation_count]}:${cmd_num_to_params[$activation_count]}}")
	[[ $dry_run ]] && eval() { printf '%q ' 'eval' "$@"; printf '\n'; } 1>&2
	# WARNING: eval executes arbitrary code - only use with trusted input
	eval -- "${cmd_to_run[@]}" & disown
}


main() {
	# Initialize variables
	name=
	delim='__'
	activation_timeout='0.3'
	prevent_overrun=
	command_string_mode=
	dry_run=
	command_segments=()
	
	parse_arguments "$@"
	validate_inputs
	setup_fifo
	parse_commands
	wait_for_activations
	execute_command
}



main "$@"
