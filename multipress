#!/usr/bin/env bash
set -o errexit


print_stderr() {
	if [[ $1 == '0' ]]; then
		[[ $2 ]] && printf "$2" "${@:3}" 1>&2 || :
	else
		[[ $2 ]] && printf '%s'"$2" "ERROR: ${0##*/}, " "${@:3}" 1>&2 || :
		exit "$1"
	fi
}



name=
delim='__'
activation_timeout='0.3'
prevent_overrun=
dry_run=
command_segs=()
while [[ "$1" ]]; do
	case $1 in
		'--name'|'-n')
			shift; name=$1 ;;
		'--delim'|'-d')
			shift; delim=$1 ;;
		'--timeout'|'-t')
			shift; activation_timeout=$1 ;;
		'--prevent-overrun'|'-p')
			prevent_overrun=1 ;;
		'--dry-run')
			dry_run=1 ;;
		'--')
			shift; break ;;
		'-'*)
			print_stderr 1 '%s\n' 'unrecognized option: '"$1" ;;
		*)
			command_segs+=("$1")
	esac
	shift
done
command_segs+=("$@")



# Checksum a string
bashash_main() {
	local \
		str=$1 \
		checksum_len=${2:-16} \
		checksum_arr=(1)
	local str_len=${#str}
	bashash__out=

	for (( i = 0; i < str_len; i++ )); do
		printf -v val '%d' "'${str:i:1}"
		checksum_arr[0]=$(( ( checksum_arr[0] + val ) % 256 ))
		for (( i2 = 1; i2 < checksum_len; i2++ )); do
			checksum_arr[i2]=$(( ( checksum_arr[i2] + checksum_arr[i2-1] ) % 256 ))
		done
	done

	printf -v bashash__out '%02x' "${checksum_arr[@]}"
}



# Eval the parameters within the exec group specified by exec_pointer
exec_pointer() {
	if [[ ${exec_pos_start[$exec_pointer]} ]]; then
		if [[ $dry_run ]]; then
			printf '%q ' "${@:${exec_pos_start[$exec_pointer]}:${exec_pos_end[$exec_pointer]}}"
			printf '\n'
		else
			eval "${@:${exec_pos_start[$exec_pointer]}:${exec_pos_end[$exec_pointer]}}" & disown
		fi
	fi
}



# Validate and define variables
[[ $delim ]] || print_stderr 1 'no command delimiter provided'
[[ ${#command_segs[@]} != '0' ]] || print_stderr 1 'no command(s) provided'


temp_dir=${TMPDIR:-${TEMPDIR:-${TMP:-${TEMP:-${XDG_RUNTIME_DIR:-/tmp}}}}}
[[ -d $temp_dir ]] || print_stderr 1 '%s\n' 'no suitable temp directory found'



# Derive the fifo path from a checksum of the instance name or the exec portion of the parameters
[[ $name ]] && bashash_main "$name" || bashash_main "${command_segs[*]}"
fifo_path=$temp_dir'/'${0##*/}'__'$USER'_'$bashash__out



# If the named piped already exists, write a newline to it and exit
if [[ -p $fifo_path ]]; then
	printf '\n' > "$fifo_path"
	exit
fi



# Create a non-blocking named piped that's deleted on EXIT
[[ -e $fifo_path ]] && rm "$fifo_path"
mkfifo --mode 0600 "$fifo_path"
exec 5<>"$fifo_path" 3>"$fifo_path" 4<"$fifo_path" 5>&-

on_exit() {
	[[ -e $fifo_path ]] && rm -f "$fifo_path"
}
trap 'on_exit' 'EXIT'



# Increment through the parameters defining the number of
# exec delimiters and where exec groups begin and end
exec_pos_start=()
exec_pos_end=()
exec_count=1
param_pos=0
for param in "${command_segs[@]}"; do

	if [[ $param == "$delim" ]]; then
		exec_pos_end[$exec_count]=$param_pos
		(( param_pos++ ))
		(( exec_count++ ))
		continue
	fi

	(( param_pos++ ))
	[[ ${exec_pos_start[$exec_count]} ]] || exec_pos_start[$exec_count]=$param_pos

done
[[ ${exec_pos_end[$exec_count]} ]] || exec_pos_end[$exec_count]=$param_pos




# If the last exec group is forced and there's only one, exec now
[[ $prevent_overrun ]] && [[ $exec_count == '1' ]] && exec_pointer "${command_segs[@]}"



# Listen on the named pipe for the specified delay time and
# increment the exec group pointer when a newline is read.
# If the pointer exceeds the number exec groups then exit.
exec_pointer=1
while read -t "$activation_timeout" -u 4; do
	(( exec_pointer++ ))
	[[ $prevent_overrun ]] && (( exec_pointer == exec_count )) && break
done
(( exec_pointer <= exec_count )) && exec_pointer "${command_segs[@]}"



